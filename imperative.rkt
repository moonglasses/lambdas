#lang racket

(require "util/env.rkt"
	 "util/misc.rkt")

(struct closure (parameters body env))

(struct ref ((val #:mutable)))

(struct id-cont ())
(struct if-cont (c a env k))
(struct set!-cont (var env k))
(struct begin-cont (e* env k))
(struct rator-cont (rand* env k))
(struct rand*-cont (proc k))
(struct evlis-cont (rest env k))
(struct cons-cont (car k)) ; expanded evlis and map&

(define val #f)
(define exp #f)
(define unev #f)
(define env #f)
(define k #f)
(define proc #f)
(define argl #f)

(define (evalk)
  (match exp
    ((? constant?) (set! val exp)
                   (apply-k))
    ((? symbol?) (set! val (ref-val (env-lookup env exp)))
                 (apply-k))
    (`(quote ,e) (set! val e)
                 (apply-k))
    (`(lambda (,x* ...) ,b ...)
     (set! val (closure x* b env))
     (apply-k))
    (`(if ,t ,c ,a)
     (set! k (if-cont c a env k))
     (set! exp t)
     (evalk))
    (`(set! ,v ,e)
     (set! k (set!-cont v env k))
     (set! exp e)
     (evalk))
    (`(begin ,e* ...)
     (set! unev e*)
     (eval-seq))
    (`(,rator ,rand* ...)
     (set! k (rator-cont rand* env k))
     (set! exp rator)
     (evalk))))

(define (apply-k)
  (match k
    ((id-cont) val)
    ((if-cont c a env1 k1)
     (set! env env1)
     (set! k k1)
     (if val
         (set! exp c)
         (set! exp a))
     (evalk))
    ((set!-cont v env1 k1)
     (set! val (set-ref-val! (env-lookup env1 v) val))
     (set! k k1)
     (apply-k))
    ((begin-cont e* env1 k1)
     (set! env env1)
     (set! k k1)
     (set! unev e*)
     (eval-seq))
    ((rator-cont rand* env1 k1)
     (set! k (rand*-cont val k1))
     (set! env env1)
     (set! unev rand*)
     (evlis))
    ((rand*-cont proc1 k1)
     (set! proc proc1)
     (set! k k1)
     (set! argl val)
     (applyk))
    ((evlis-cont e* env1 k1)
     (set! k (cons-cont val k1))
     (set! env env1)
     (set! unev e*)
     (evlis))
    ((cons-cont car k1)
     (set! val (cons car val))
     (set! k k1)
     (apply-k))))

(define (applyk)
  (if (procedure? proc)
      (begin (set! val (apply proc argl))
             (apply-k))
      (begin (set! unev (closure-body proc))
             (set! env (env-extend* (closure-env proc)
                                    (closure-parameters proc)
                                    (map ref argl)))
             (eval-seq))))

(define (eval-seq)
  (if (singleton? unev)
      (begin (set! exp (first unev))
             (evalk))
      (begin (set! k (begin-cont (rest unev) env k))
             (set! exp (first unev))
             (evalk))))

(define (evlis)
  (if (null? unev)
      (begin (set! val '())
             (apply-k))
      (begin (set! k (evlis-cont (rest unev) env k))
             (set! exp (first unev))
             (evalk))))       


(define initial-env
  (make-env
   `((+ . ,(ref +))
     (- . ,(ref -))
     (/ . ,(ref /))
     (* . ,(ref *))
     (equal? . ,(ref equal?))
     (display . ,(ref display)))))

(define initial-cont
  (id-cont))

(define (eval e)
  (set! exp e)
  (set! k initial-cont)
  (set! env initial-env)
  (evalk))
